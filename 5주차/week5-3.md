[ Date : 2017. 02. 12 ]

					-------------------- Today's Topic ------------------
									(1) 웹뷰에 백버튼 추가하기
									(2) MyUtility 백버튼에 스택 추가하기
									(3) SOLID – OOP 설계원칙결합
					-----------------------------------------------------

프로젝트 명 : [MyUtility]

내용 : 기존의 탭뷰들에 백버튼 기능을 보완하였습니다.

-------------------------------------------------------------

# 1. 웹뷰에 백버튼 추가하기

[사진으로 보여주기]

기존 코드에서 문제점은 WebVew에서 인터넷 서핑을 하던 중 뒤로가기 버튼을 누르면 이전 인터넷 페이지로 넘어가지 않고 애플리케이션이 종료되었습니다. 백버튼에 새로운 기능을 추가함으로써, 사용자에게 이전에 보았던 인터넷 페이지 화면을 띄웁니다.

[MainActivity.java]
![](http://i.imgur.com/oxW44xx.png)

(1) page_position은 전역변수로 선언하였기 때문에 현재 어느 탭에 있는지 알 수 있습니다.

(2) case 2 문은 웹뷰 탭입니다. ThreeFragment 타입의 인스턴스 참조변수인 three.goback()은 현재 웹페이지에서 뒤로가기가 가능한지를 확인합니다.
(goBackStack()은 2장에서 설명하겠습니다......)

(3) 기본적인 연산은 웹페이지 뒤로가기가 가능하면 이전 페이지로 가지만 그렇지 않을 경우 앱으 종료시킵니다.


[ ThreeFragment.java -- goBack() ]
![](http://i.imgur.com/J7RNPPI.png)

--> 백버튼이 클릭 될 때 웹뷰의 goBack() 메소드를 호출합니다. 이 코드는 앞으로 웹뷰 처리시 계속 가져다 쓰시면 도움 될 겁니다 ㅎㅎㅎㅎㅎ


-------------------------------------------------------------

# 2. MyUtility 백버튼에 스택 추가하기

[사진으로 보여주기]

위와 같은 처리를 위해서는 스택 구조에 각 탭의 position 값을 저장해두어야 합니다. 이 스택 처리를 위해서는 크게 3가지 조건이 필요합니다.

					- 스택 구조를 처리하기 위한 자료구조
					- 페이지가 변경될 때마다 스택에 push() 저장한다.
					- 백버튼을 누를 때마다 스택에서 pop()하여 꺼낸다.

##2.1 스택 구조를 처리하기 위한 자료구조

			    // 페이지 이동 경로를 저장하는 스택 변수
			    private Stack<Integer> pageStack = new Stack<>();

--> 자바에서 지원해주는 Stack을 사용할 겁니다. 여기는 push()와 pop()이 이미 구현되어 있기 때문에 사용하기 편합니다^^


##2.2 페이지가 변경될 때마다 스택에 push() 저장한다.

![](http://i.imgur.com/xGamlaX.png)

(1) 페이지가 변경될 때마다 onPageSelected()가 호출되면서 페이지 값이 position으로 넘어오게 됩니다.

(2) backPress는 사용자가 백버튼을 눌렀을 때를 체크하기 위한 상태 변수 입니다.
만약 사용자가 백버튼을 누르지 않았다면, 페이지가 바뀐 후, 바로 이전 페이지까지를 스택에 저장(push)합니다.
사용자가 백버튼을 눌렀다면, backPress를 다시 false로 바꿉니다.(왜? 백버튼을 눌렀을 때는, 페이지를 스택에 저장하지 않고 다음 작업을 위해 backPRess 원래상태인 false로 다시 복귀시켜야 합니다.)  

(3) position은 현재 바뀐 페이지이고 page_position은 이전 페이지까지를 나타냅니다.

##2.3 백버튼을 누를 때마다 스택에서 pop()하여 꺼낸다.

![](http://i.imgur.com/9K5eJEN.png)

(1) 백버튼을 눌렀을 때, 스택 사이즈가 하나만 남았을 때는 보여줄 웹 페이지가 없기 때문에 바로 종료합니다.

(2) 백버튼을 눌렀을 때, 스택 사이즈가 1보다 크면 backPress를 true로 바꾸어야 onPageSelected()가 호출될 때, 바뀐 페이지가 스택에 저장되지 않습니다.


(3) 스택에 가장 마지막에 들어온 페이지를 pop()으로 꺼낸 뒤 viewPager에 세팅합니다.


-------------------------------------------------------------

# 3. SOLID – OOP 설계원칙결합


##3.1 SRP(단일책임의 원칙: Single Responsibility Principle) 

클래스와 클래스간의 응집도는 높이고 결합도는 낮춥니다.

##3.2 OCP(개방폐쇄의 원칙: Open Close Principle) 

기존의 클래스를 사용할 때, 클래스 안의 내용을 수정하기 보다는 확장(extends)하여 재사용할 수 있어야 합니다.



##3.3 LSP(리스코브 치환의 원칙: The Liskov Substitution Principle)

자식 타입의 객체는 부모 타입의 객체로 교체될수 있어야합니다.

이 말이 이해가 되지 않는다면 다음 상황을 보시면 됩니다.

![](http://i.imgur.com/HQ3pyEi.png)

--> 추상 클래스 Shape를 클래스 Rectangle과 Triangle가 상속하고 있습니다. 이 때, 아래 코드를 보면,

							Shape shape1 = new Triangle();
							shape1.draw();

Shape(부모)타입의 shape1은 포인터이고 Triangle() 인스턴스(자식)를 가리키고 있습니다. 하지만 Shape라는 필터링을 거치면서 shape1은 Shape에 선언되어있는 함수들만 보이게 됩니다.


##3.4 ISP(인터페이스 분리의 원칙: Interface Segregation Principle)

'하나의 일반적인 인터페이스보다는, 여러 개의 구체적인 인터페이스가 낫다'라고 정의할 수 있습니다. 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원리입니다. 즉 어떤 클래스가 다른 클래스에 종속될 때에는 가능한 최소한의 인터페이스만을 사용해야 합니다.

##3.5 DIP (의존성역전의 원칙: Dependency Inversion Principle)

의존 관계의 역전 Dependency Inversion 이란 구조적 디자인에서 발생하던 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 위계관계를 끊는 의미의역전입니다. 실제 사용 관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고 받음으로써 관계를 최대한 느슨하게 만드는 원칙입니다.

즉, week5-5의 옵저버 패턴을 생각하시면 됩니다. 클라이언트(Student)와 서버(KakaoTalkServer) 사이에는 직접적인 의존관계가 발생하지 않고 클라이언트가 구현한 인터페이스 혹은 클라이언트의 부모(추상 클래스)를 통해서 통신합니다. 서버에 등록되어있는 클라이언트 혹은 옵저버들은 서버가 필요한 상황에만(서버 내용이 변경되는 경우) 옵저버에 정의되어있는 update() 메소드를 호출합니다. 이 클라이언트의 update() 메소드는 클라이언트의 부모 클래스 타입으로 정의된 참조 변수로 접근하게 됩니다. 따라서 각각의 클라리언트들과는 직접적인 연관이 발생하지 않고 오로지 부모 타입의 참조변수로써 서버와 클라이언트간의 관계는 느슨해집니다.

